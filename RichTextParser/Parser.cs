// Machine generated by peg-sharp 1.0.0.0 from ../../RichTextParser/Parser.peg.

using System;
using System.Collections.Generic;
using System.Globalization;
//using System.Linq;								// TODO: this is handy enough that we'd like to include it by default, but we want the generated parsers to work with .NET 2.0 for now
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using RichTextParser;

[Serializable]
internal sealed partial class ParserException : Exception
{
	public ParserException(int line, int col, int offset, string file, string input, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
	{
		File = file;
		Line = line;
		Col = col;
	}
	
	public string File {get; private set;}
	public int Line {get; private set;}
	public int Col {get; private set;}
}

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class Parser
{
	public Parser()
	{
		m_nonterminals[(int)NonTerminalEnum.Start] = new ParseMethod[]{this.DoParseStartRule};
		m_nonterminals[(int)NonTerminalEnum.Words] = new ParseMethod[]{this.DoParseWordsRule};
		m_nonterminals[(int)NonTerminalEnum.Word] = new ParseMethod[]{this.DoParseWordRule};
		m_nonterminals[(int)NonTerminalEnum.String] = new ParseMethod[]{this.DoParseStringRule};
		m_nonterminals[(int)NonTerminalEnum.MixString] = new ParseMethod[]{this.DoParseMixStringRule};
		m_nonterminals[(int)NonTerminalEnum.HyperText] = new ParseMethod[]{this.DoParseHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.EscapeLeftTag] = new ParseMethod[]{this.DoParseEscapeLeftTagRule};
		m_nonterminals[(int)NonTerminalEnum.LeftTag] = new ParseMethod[]{this.DoParseLeftTagRule};
		m_nonterminals[(int)NonTerminalEnum.ComplexHyperText] = new ParseMethod[]{this.DoParseComplexHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.SimpleHyperText] = new ParseMethod[]{this.DoParseSimpleHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.DocTypeHyperText] = new ParseMethod[]{this.DoParseDocTypeHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.CommentHyperText] = new ParseMethod[]{this.DoParseCommentHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.CommentText] = new ParseMethod[]{this.DoParseCommentTextRule};
		m_nonterminals[(int)NonTerminalEnum.DocTypeEnd] = new ParseMethod[]{this.DoParseDocTypeEndRule};
		m_nonterminals[(int)NonTerminalEnum.HyperWord] = new ParseMethod[]{this.DoParseHyperWordRule};
		m_nonterminals[(int)NonTerminalEnum.EmbedWord] = new ParseMethod[]{this.DoParseEmbedWordRule};
		m_nonterminals[(int)NonTerminalEnum.EndHyperText] = new ParseMethod[]{this.DoParseEndHyperTextRule};
		m_nonterminals[(int)NonTerminalEnum.EndTagText] = new ParseMethod[]{this.DoParseEndTagTextRule};
		m_nonterminals[(int)NonTerminalEnum.Attrs] = new ParseMethod[]{this.DoParseAttrsRule};
		m_nonterminals[(int)NonTerminalEnum.Attr] = new ParseMethod[]{this.DoParseAttrRule};
		m_nonterminals[(int)NonTerminalEnum.KeyValue] = new ParseMethod[]{this.DoParseKeyValueRule};
		m_nonterminals[(int)NonTerminalEnum.KeyNoValue] = new ParseMethod[]{this.DoParseKeyNoValueRule};
		m_nonterminals[(int)NonTerminalEnum.Id] = new ParseMethod[]{this.DoParseIdRule};
		m_nonterminals[(int)NonTerminalEnum.Value] = new ParseMethod[]{this.DoParseValueRule};
		m_nonterminals[(int)NonTerminalEnum.NotStrId] = new ParseMethod[]{this.DoParseNotStrIdRule};
		m_nonterminals[(int)NonTerminalEnum.NotStrVal] = new ParseMethod[]{this.DoParseNotStrValRule};
		m_nonterminals[(int)NonTerminalEnum.Str1] = new ParseMethod[]{this.DoParseStr1Rule};
		m_nonterminals[(int)NonTerminalEnum.Str2] = new ParseMethod[]{this.DoParseStr2Rule};
		m_nonterminals[(int)NonTerminalEnum.S0] = new ParseMethod[]{this.DoParseS0Rule};
		m_nonterminals[(int)NonTerminalEnum.S] = new ParseMethod[]{this.DoParseSRule};
		m_nonterminals[(int)NonTerminalEnum.EOF] = new ParseMethod[]{this.DoParseEOFRule};

		m_ParseMethod1 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Words);};
		m_ParseMethod2 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EOF);};
		m_ParseMethod3 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Word);};
		m_ParseMethod4 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.String);};
		m_ParseMethod5 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.MixString);};
		m_ParseMethod6 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "<", string.Empty, null, "[^<]");};
		m_ParseMethod7 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperText);};
		m_ParseMethod8 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag);};
		m_ParseMethod9 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.LeftTag);};
		m_ParseMethod10 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.ComplexHyperText);};
		m_ParseMethod11 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.SimpleHyperText);};
		m_ParseMethod12 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.DocTypeHyperText);};
		m_ParseMethod13 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.CommentHyperText);};
		m_ParseMethod14 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "<");};
		m_ParseMethod15 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attrs);};
		m_ParseMethod16 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, ">");};
		m_ParseMethod17 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperWord);};
		m_ParseMethod18 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EndHyperText);};
		m_ParseMethod19 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "<");};
		m_ParseMethod20 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attrs);};
		m_ParseMethod21 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "/>");};
		m_ParseMethod22 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "<!");};
		m_ParseMethod23 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attrs);};
		m_ParseMethod24 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.DocTypeEnd);};
		m_ParseMethod25 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "<!--");};
		m_ParseMethod26 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.CommentText);};
		m_ParseMethod27 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "-->");};
		m_ParseMethod31 = (ParseMethod)delegate (State s, List<Result> r) {return DoSequence(s, r,
				m_ParseMethod28,
				m_ParseMethod30);};
		m_ParseMethod28 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoNAssert(s2, r2,
					m_ParseMethod29);};
		m_ParseMethod29 = (ParseMethod)delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, null, "-->");};
		m_ParseMethod30 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, false, string.Empty, "\x0001\xFFFF", null, ".");};
		m_ParseMethod32 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, ">");};
		m_ParseMethod33 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "/>");};
		m_ParseMethod34 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EmbedWord);};
		m_ParseMethod35 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.String);};
		m_ParseMethod36 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.HyperText);};
		m_ParseMethod37 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EscapeLeftTag);};
		m_ParseMethod38 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "</");};
		m_ParseMethod39 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.EndTagText);};
		m_ParseMethod40 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, ">");};
		m_ParseMethod41 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, true, "<>", string.Empty, null, "[^<>]");};
		m_ParseMethod42 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Attr);};
		m_ParseMethod43 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.KeyValue);};
		m_ParseMethod44 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.KeyNoValue);};
		m_ParseMethod45 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod46 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Id);};
		m_ParseMethod47 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod48 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "=");};
		m_ParseMethod49 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod50 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Value);};
		m_ParseMethod51 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod52 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod53 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Id);};
		m_ParseMethod54 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S0);};
		m_ParseMethod55 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.NotStrId);};
		m_ParseMethod56 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str1);};
		m_ParseMethod57 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str2);};
		m_ParseMethod58 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.NotStrVal);};
		m_ParseMethod59 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str1);};
		m_ParseMethod60 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.Str2);};
		m_ParseMethod61 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, false, "_#@$%&.:", "azAZ09", null, "[_#@$%&.:a-zA-Z0-9]");};
		m_ParseMethod62 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod63);};
		m_ParseMethod63 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "<>=\t\r\n /", string.Empty, null, "[^<>=\t\r\n /]");};
		m_ParseMethod66 = (ParseMethod)delegate (State s, List<Result> r) {return DoChoice(s, r,
				m_ParseMethod64,
				m_ParseMethod65);};
		m_ParseMethod64 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, false, "_#@$%&+.:", "azAZ09", null, "[_#@$%&+.:a-zA-Z0-9]");};
		m_ParseMethod65 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, null, "-");};
		m_ParseMethod67 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod68);};
		m_ParseMethod68 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "<>=\t\r\n /", string.Empty, null, "[^<>=\t\r\n /]");};
		m_ParseMethod69 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "\"");};
		m_ParseMethod70 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod71);};
		m_ParseMethod71 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "\"", string.Empty, null, "[^\"]");};
		m_ParseMethod72 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "\"");};
		m_ParseMethod73 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "'");};
		m_ParseMethod74 = (ParseMethod)delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				m_ParseMethod75);};
		m_ParseMethod75 = (ParseMethod)delegate (State s2, List<Result> r2) {return DoParseRange(s2, null, true, "'", string.Empty, null, "[^']");};
		m_ParseMethod76 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseLiteral(s, null, "'");};
		m_ParseMethod77 = (ParseMethod)delegate (State s, List<Result> r) {return DoParse(s, r, (int)NonTerminalEnum.S);};
		m_ParseMethod78 = (ParseMethod)delegate (State s, List<Result> r) {return DoParseRange(s, null, false, string.Empty, "\x0001\xFFFF", null, ".");};


        OnCtorEpilog();
	}
	
	public ParserValue Parse(string input)
	{
		return DoParseFile(input, null, (int)NonTerminalEnum.Start);
	}
	
	// File is used for error reporting.
	public ParserValue Parse(string input, string file)
	{
		return DoParseFile(input, file, (int)NonTerminalEnum.Start);
	}
	
	#region Non-Terminal Parse Methods
	// Start := Words EOF
	private State DoParseStartRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod1,
			m_ParseMethod2);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Words := Word*
	private State DoParseWordsRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod3);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.TextValues = new List<IRichText>();foreach(var v in results)value.TextValues.Add(v.Value.TextValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Word := String / MixString
	private State DoParseWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod4,
			m_ParseMethod5);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// String := [^<]+
	private State DoParseStringRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 1, 2147483647,
			m_ParseMethod6);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.TextValue = new NormalText{ Text = text };
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// MixString := HyperText / EscapeLeftTag / LeftTag
	private State DoParseMixStringRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod7,
			m_ParseMethod8,
			m_ParseMethod9);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// HyperText := ComplexHyperText / SimpleHyperText / DocTypeHyperText / CommentHyperText
	private State DoParseHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod10,
			m_ParseMethod11,
			m_ParseMethod12,
			m_ParseMethod13);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EscapeLeftTag := '<<'
	private State DoParseEscapeLeftTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "<<");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "<" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// LeftTag := '<'
	private State DoParseLeftTagRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoParseLiteral(_state, null, "<");
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			value.TextValue = new NormalText{ Text = "<" };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// ComplexHyperText := '<' Attrs '>' HyperWord EndHyperText
	private State DoParseComplexHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod14,
			m_ParseMethod15,
			m_ParseMethod16,
			m_ParseMethod17,
			m_ParseMethod18);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			var ht = new HyperText();ht.Attrs.AddRange(results[0].Value.AttrValues);ht.Texts.AddRange(results[1].Value.TextValues);ht.EndTag = results[2].Value.StringValue;value.TextValue = ht;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// SimpleHyperText := '<' Attrs '/>'
	private State DoParseSimpleHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod19,
			m_ParseMethod20,
			m_ParseMethod21);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			var ht = new HyperText();ht.Attrs.AddRange(results[0].Value.AttrValues);value.TextValue = ht;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// DocTypeHyperText := '<!' Attrs DocTypeEnd
	private State DoParseDocTypeHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod22,
			m_ParseMethod23,
			m_ParseMethod24);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			var uht = new UnusedHyperText();uht.Attrs.AddRange(results[0].Value.AttrValues);value.TextValue = uht;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// CommentHyperText := '<!--' CommentText '-->'
	private State DoParseCommentHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod25,
			m_ParseMethod26,
			m_ParseMethod27);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.TextValue = new UnusedHyperText{ Text = results[0].Value.StringValue };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// CommentText := (!'-->' .)*
	private State DoParseCommentTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod31);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// DocTypeEnd := '>' / '/>'
	private State DoParseDocTypeEndRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod32,
			m_ParseMethod33);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// HyperWord := EmbedWord*
	private State DoParseHyperWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod34);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.TextValues = new List<IRichText>();foreach(var v in results)value.TextValues.Add(v.Value.TextValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EmbedWord := String / HyperText / EscapeLeftTag
	private State DoParseEmbedWordRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod35,
			m_ParseMethod36,
			m_ParseMethod37);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EndHyperText := '</' EndTagText '>'
	private State DoParseEndHyperTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod38,
			m_ParseMethod39,
			m_ParseMethod40);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.StringValue = results[0].Value.StringValue;
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EndTagText := [^<>]+
	private State DoParseEndTagTextRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 1, 2147483647,
			m_ParseMethod41);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Attrs := Attr+
	private State DoParseAttrsRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoRepetition(_state, results, 1, 2147483647,
			m_ParseMethod42);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValues = new List<HyperTextAttr>();foreach(var v in results)value.AttrValues.Add(v.Value.AttrValue);
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Attr := KeyValue / KeyNoValue
	private State DoParseAttrRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoChoice(_state, results,
			m_ParseMethod43,
			m_ParseMethod44);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// KeyValue := S0 Id S0 '=' S0 Value S0
	private State DoParseKeyValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod45,
			m_ParseMethod46,
			m_ParseMethod47,
			m_ParseMethod48,
			m_ParseMethod49,
			m_ParseMethod50,
			m_ParseMethod51);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValue = new HyperTextAttr{ Key = results[0].Value.StringValue, Value = results[1].Value.StringValue };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// KeyNoValue := S0 Id S0
	private State DoParseKeyNoValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod52,
			m_ParseMethod53,
			m_ParseMethod54);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
			value.AttrValue = new HyperTextAttr{ Key = results[0].Value.StringValue };
			
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Id := NotStrId / Str1 / Str2
	private State DoParseIdRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoChoice(_state, results,
			m_ParseMethod55,
			m_ParseMethod56,
			m_ParseMethod57);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Value := NotStrVal / Str1 / Str2
	private State DoParseValueRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoChoice(_state, results,
			m_ParseMethod58,
			m_ParseMethod59,
			m_ParseMethod60);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// NotStrId := [_#@$%&.:a-zA-Z0-9] [^<>=\t\r\n /]*
	private State DoParseNotStrIdRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoSequence(_state, results,
			m_ParseMethod61,
			m_ParseMethod62);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// NotStrVal := ([_#@$%&+.:a-zA-Z0-9] / '-') [^<>=\t\r\n /]*
	private State DoParseNotStrValRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoSequence(_state, results,
			m_ParseMethod66,
			m_ParseMethod67);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			value.StringValue = text;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Str1 := '"' [^\"]* '"'
	private State DoParseStr1Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod69,
			m_ParseMethod70,
			m_ParseMethod72);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// Str2 := ''' [^']* '''
	private State DoParseStr2Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoSequence(_state, results,
			m_ParseMethod73,
			m_ParseMethod74,
			m_ParseMethod76);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// S0 := S*
	private State DoParseS0Rule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
        List<Result> results = null;
		
			_state = DoRepetition(_state, results, 0, 2147483647,
			m_ParseMethod77);
		
		if (_state.Parsed)
		{
            ParserValue value = default(ParserValue);
        
			string text = m_input.Substring(_startIndex, _state.Index - _startIndex);
			
			text=null;
			
			if (null != text && null != _outResults)
				_outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// S := [\r\n\t ]
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoParseRange(_state, null, false, "\r\n\t ", string.Empty, null, "[\r\n\t ]");
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	// EOF := !.
	private State DoParseEOFRule(State _state, List<Result> _outResults)
	{
		int _startIndex = _state.Index;
		List<Result> results = new List<Result>();
		
			_state = DoNAssert(_state, results,
			m_ParseMethod78);
		
		if (_state.Parsed)
		{
			ParserValue value = results.Count > 0 ? results[0].Value : default(ParserValue);
        
            if(null != _outResults)
                _outResults.Add(new Result(this, _startIndex, _state.Index - _startIndex, m_input, ref value));
		}
			
		return _state;
	}

	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
    partial void useliteralresult();
    partial void userangeresult();

	private void DoBuildLineStarts()
	{
		m_lineStarts = new List<int>();
		
		m_lineStarts.Add(0);		// line 1 starts at index 0 (even if we have no text)
		
		int i = 0;
		while (i < m_input.Length)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				m_lineStarts.Add(++i);
			}
			else if (ch == '\r')
			{
				m_lineStarts.Add(i);
			}
			else if (ch == '\n')
			{
				m_lineStarts.Add(i);
			}
		}
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		int startIndex = state.Index;
		int startResult = null == results ? 0 : results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(startIndex, false);
                if(null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	public string DoEscapeAll(string s)
	{
		System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index;
	}
	
	// This is most often used just for error handling where it is a bit overkill.
	// However it's also sometimes used in rule prologs where efficiency is more
	// important (and doing a bit of extra work in the error case is not very harmful).
	private int DoGetLine(int index)
	{
		if (m_lineStarts == null)
			DoBuildLineStarts();
			
		int line = m_lineStarts.BinarySearch(index);
		if (line >= 0)
			return line + 1;
			
		return ~line;
	}
	
	private State DoNAssert(State state, List<Result> results, ParseMethod method)
	{
		State temp = method(state, results);
		
		state = new State(state.Index, !temp.Parsed);
		
		return state;
	}
	
	private State DoParse(State state, List<Result> results, int nonterminal)
	{
		int startIndex = state.Index;
		
		CacheValue cache;
        long key = CacheValue.CalcKey(nonterminal, startIndex);
        if (!m_cache.TryGetValue(key, out cache)) {
            if (nonterminal < 0 || nonterminal >= (int)NonTerminalEnum.NonTerminalNum)
                throw new Exception("Couldn't find a " + nonterminal + " parse method");

            ParseMethod[] methods = m_nonterminals[(int)nonterminal];
            int oldCount = null == results ? 0 : results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && null!= results && results.Count > oldCount;
			ParserValue value = hasResult ? results[results.Count - 1].Value : default(ParserValue);
			cache = new CacheValue(ref state, ref value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult && null != results)
                results.Add(new Result(this, startIndex, cache.State.Index - startIndex, m_input, ref cache.Value));

		}
		
		return cache.State;
	}
	
	private ParserValue DoParseFile(string input, string file, int rule)
	{
		m_file = file;
		m_input = m_file;				                    // we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";		                    // add a sentinel so we can avoid range checks
		m_cache.Clear();
		m_lineStarts = null;
		
		State state = new State(0, true);
		List<Result> results = new List<Result>();
		OnParseProlog();
		state = DoParse(state, results, rule);
			
		int i = state.Index;
        if (!state.Parsed) {
            DoThrow(i, "Input syntax error !");
        } else if (i < input.Length) {
            DoThrow(i, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
        }
		OnParseEpilog(state);
		
		return results[0].Value;
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		State result;
		
		if (string.Compare(m_input, state.Index, literal, 0, literal.Length) == 0)
		{
            if (null != results) {
                results.Add(new Result(this, state.Index, literal.Length, m_input));
            }
			result = new State(state.Index + literal.Length, true);
		}
		else
		{
			result = new State(state.Index, false);
		}
		
		return result;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
            if (null != results) {
                results.Add(new Result(this, state.Index, 1, m_input));
            }
			return new State(state.Index + 1, true);
		}
		
		return new State(state.Index, false);
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		int startIndex = state.Index;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
                if (count >= min && count <= max) {
                    state = new State(state.Index, true);
                }
				break;
			}
		}

        if (count < min || count > max) {
            state = new State(startIndex, false);
        }
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		int startIndex = state.Index;
		int startResult = null == results ? 0 :results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(startIndex, false);
                if(null != results)
                    results.RemoveRange(startResult, results.Count - startResult);
                break;
			}
		}
		
		return state;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index) + 1;	// editors seem to usually use 1-based cols so that's what we will report
		
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(format));
	}
    #endregion

    #region Private Types
    private struct CacheValue
	{
		public CacheValue(ref State state, ref ParserValue value, bool hasResult)	
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State;
		public ParserValue Value;
		public bool HasResult;

        public static long CalcKey(int rule, int index)
        {
            long v1 = rule;
            long v2 = index;
            return (v1 << 32) + v2;
        }
    }
	
	private delegate State ParseMethod(State state, List<Result> results);
		
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
		}
		
		// Index of the first unconsumed character.
		public int Index;
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed;
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
        public Result(Parser parser, int index, int length, string input)
        {
            m_parser = parser;
            m_index = index;
            m_length = length;
            m_input = input;
            Value = default(ParserValue);
        }

        public Result(Parser parser, int index, int length, string input, ref ParserValue value)
        {
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 0-based character index the (non)terminal started on.
		public int Index {get {return m_index;}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
			
		// For non-terminals this will be the result of the semantic action,
		// otherwise it will be the default value.
		public ParserValue Value;
		
		private Parser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
    #endregion

    #region Fields
    private enum NonTerminalEnum
    {
		Start,
		Words,
		Word,
		String,
		MixString,
		HyperText,
		EscapeLeftTag,
		LeftTag,
		ComplexHyperText,
		SimpleHyperText,
		DocTypeHyperText,
		CommentHyperText,
		CommentText,
		DocTypeEnd,
		HyperWord,
		EmbedWord,
		EndHyperText,
		EndTagText,
		Attrs,
		Attr,
		KeyValue,
		KeyNoValue,
		Id,
		Value,
		NotStrId,
		NotStrVal,
		Str1,
		Str2,
		S0,
		S,
		EOF,
        NonTerminalNum
    }

	private ParseMethod m_ParseMethod1;
	private ParseMethod m_ParseMethod2;
	private ParseMethod m_ParseMethod3;
	private ParseMethod m_ParseMethod4;
	private ParseMethod m_ParseMethod5;
	private ParseMethod m_ParseMethod6;
	private ParseMethod m_ParseMethod7;
	private ParseMethod m_ParseMethod8;
	private ParseMethod m_ParseMethod9;
	private ParseMethod m_ParseMethod10;
	private ParseMethod m_ParseMethod11;
	private ParseMethod m_ParseMethod12;
	private ParseMethod m_ParseMethod13;
	private ParseMethod m_ParseMethod14;
	private ParseMethod m_ParseMethod15;
	private ParseMethod m_ParseMethod16;
	private ParseMethod m_ParseMethod17;
	private ParseMethod m_ParseMethod18;
	private ParseMethod m_ParseMethod19;
	private ParseMethod m_ParseMethod20;
	private ParseMethod m_ParseMethod21;
	private ParseMethod m_ParseMethod22;
	private ParseMethod m_ParseMethod23;
	private ParseMethod m_ParseMethod24;
	private ParseMethod m_ParseMethod25;
	private ParseMethod m_ParseMethod26;
	private ParseMethod m_ParseMethod27;
	private ParseMethod m_ParseMethod28;
	private ParseMethod m_ParseMethod29;
	private ParseMethod m_ParseMethod30;
	private ParseMethod m_ParseMethod31;
	private ParseMethod m_ParseMethod32;
	private ParseMethod m_ParseMethod33;
	private ParseMethod m_ParseMethod34;
	private ParseMethod m_ParseMethod35;
	private ParseMethod m_ParseMethod36;
	private ParseMethod m_ParseMethod37;
	private ParseMethod m_ParseMethod38;
	private ParseMethod m_ParseMethod39;
	private ParseMethod m_ParseMethod40;
	private ParseMethod m_ParseMethod41;
	private ParseMethod m_ParseMethod42;
	private ParseMethod m_ParseMethod43;
	private ParseMethod m_ParseMethod44;
	private ParseMethod m_ParseMethod45;
	private ParseMethod m_ParseMethod46;
	private ParseMethod m_ParseMethod47;
	private ParseMethod m_ParseMethod48;
	private ParseMethod m_ParseMethod49;
	private ParseMethod m_ParseMethod50;
	private ParseMethod m_ParseMethod51;
	private ParseMethod m_ParseMethod52;
	private ParseMethod m_ParseMethod53;
	private ParseMethod m_ParseMethod54;
	private ParseMethod m_ParseMethod55;
	private ParseMethod m_ParseMethod56;
	private ParseMethod m_ParseMethod57;
	private ParseMethod m_ParseMethod58;
	private ParseMethod m_ParseMethod59;
	private ParseMethod m_ParseMethod60;
	private ParseMethod m_ParseMethod61;
	private ParseMethod m_ParseMethod62;
	private ParseMethod m_ParseMethod63;
	private ParseMethod m_ParseMethod64;
	private ParseMethod m_ParseMethod65;
	private ParseMethod m_ParseMethod66;
	private ParseMethod m_ParseMethod67;
	private ParseMethod m_ParseMethod68;
	private ParseMethod m_ParseMethod69;
	private ParseMethod m_ParseMethod70;
	private ParseMethod m_ParseMethod71;
	private ParseMethod m_ParseMethod72;
	private ParseMethod m_ParseMethod73;
	private ParseMethod m_ParseMethod74;
	private ParseMethod m_ParseMethod75;
	private ParseMethod m_ParseMethod76;
	private ParseMethod m_ParseMethod77;
	private ParseMethod m_ParseMethod78;


    private string m_input;
	private string m_file;
    private ParseMethod[][] m_nonterminals = new ParseMethod[(int)NonTerminalEnum.NonTerminalNum][];
    private Dictionary<long, CacheValue> m_cache = new Dictionary<long, CacheValue>();
	private List<int> m_lineStarts;		// offsets at which each line starts
	#endregion
}


